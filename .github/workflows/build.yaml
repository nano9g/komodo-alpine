name: komodo-alpine-build
run-name: Build Komodo binaries for Alpine

on:
  # There's no way to trigger on push to another repo, so we're going to run the
  # release-check job periodically, which will determine whether the rest of the
  # workflow needs to run
  schedule:
    - cron: '15 */4 * * *'

  workflow_dispatch:

env:
  KOMODO_REPO: moghtech/komodo
  
  # Path (in the Komodo repo) to the file that will be passed to "docker buildx build"
  BINARIES_DOCKERFILE: bin/binaries.Dockerfile
  
  # Lines to remove from the Dockerfile for things we aren't building
  # (Will be used in a regex, so separate multiple items with a pipe |)
  # Matching "cargo build -p komodo_<DOCKERFILE_CARGO_BUILD_REMOVE> --release && \"
  DOCKERFILE_CARGO_BUILD_REMOVE: 'core|cli'
  # Matching "COPY --from=builder /builder/target/release/<DOCKERFILE_COPY_FROM_BUILDER_REMOVE> /km"
  DOCKERFILE_COPY_FROM_BUILDER_REMOVE: 'core|km'
  
  # Rust Alpine Docker image tag suffix (rust:X.Y.Z-alpineX.Y)
  ALPINE_IMAGE_TAG: alpine3.22

jobs:
  # This is the lightweight job that runs and decides whether to perform builds
  release-check:
    name: Komodo version check
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      komodo_tag: ${{ steps.check.outputs.komodo_tag }}
      komodo_release_url: ${{ steps.check.outputs.komodo_release_url }}
      tag_to_create: ${{ steps.check.outputs.tag_to_create }}

    steps:
      - name: Check
        id: check
        shell: bash
        run: |
          # Compare our release tag with that of the official Komodo repo to see if a new build is needed
          should_run=false

          latest_komodo_release=$(curl --no-progress-meter "${GITHUB_API_URL}/repos/${KOMODO_REPO}/releases?per_page=1")
          komodo_tag=$(echo "$latest_komodo_release" | jq -r '.[0].tag_name')
          komodo_release_url=$(echo "$latest_komodo_release" | jq -r '.[0].html_url')
          
          our_tag=$(curl --no-progress-meter "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/releases?per_page=1" | jq -r '.[0].tag_name')
          tag_to_create=$komodo_tag

          # Force run for testing
          #tag_to_create=$(date +%s)
          
          if [[ "$komodo_tag" != "$tag_to_create" ]]; then
            should_run=true
          fi

          echo "Komodo tag: $komodo_tag"
          echo "Our latest tag: $our_tag"
          echo "Tag to create: $tag_to_create"
          echo "Should run?: $should_run"

          echo "komodo_tag=${komodo_tag}" >> $GITHUB_OUTPUT
          echo "komodo_release_url=${komodo_release_url}" >> $GITHUB_OUTPUT
          echo "tag_to_create=${tag_to_create}" >> $GITHUB_OUTPUT
          echo "should_run=${should_run}" >> $GITHUB_OUTPUT


  # Actual builds, only invoked when release-check says it's needed
  komodo-build:
    name: Build and release
    runs-on: ${{ matrix.os }}
    needs: release-check
    if: needs.release-check.outputs.should_run == 'true'
    
    env:
      BUILD_PLATFORM: linux/${{ matrix.arch }}
      # Subfolder for build artifacts so we can place them in a known location
      OUTPUT_FOLDER: __build

    # Using a matrix so we can build with native runners instead of using QEMU emulation (native is literally 10x faster)
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            arch: amd64
          - os: ubuntu-24.04-arm
            arch: arm64

    steps:

      - name: Checkout current Komodo release
        uses: actions/checkout@v4
        with:
          repository: ${{ env.KOMODO_REPO }}
          ref: ${{ needs.release-check.outputs.komodo_tag }}
          path: komodo

      - name: Prepare
        shell: bash
        working-directory: ${{ github.workspace }}/komodo
        run: |
          echo "Creating build artifact folder"
          mkdir -p $OUTPUT_FOLDER

          # Update Dockerfile
          echo -e "-----\nModified $BINARIES_DOCKERFILE\n------\n"
          # Build using the Alpine image (obvs)
          sed -i -E "s/(^FROM rust:[^-]+-)([^ ]+) /\1${ALPINE_IMAGE_TAG} /" $BINARIES_DOCKERFILE
          # Alpine build deps
          sed -i "/^WORKDIR \/builder/i ARG TARGETARCH\nRUN apk add --no-cache musl-dev\n" $BINARIES_DOCKERFILE
          # Remove commands for things we're not building
          # Preserve continuations for build commands (&& \) to avoid errors if things are reordered
          sed -i -E 's/cargo build.*komodo_(core|cli) --release(.*)?/echo "Skipping \1"\2/' $BINARIES_DOCKERFILE
          sed -i -E '/COPY.*--from.*\/(core|km)/d' $BINARIES_DOCKERFILE
          # Add architecture suffixes to artifacts
          sed -i -E '/^FROM scratch/a ARG TARGETARCH' $BINARIES_DOCKERFILE
          sed -i -E '/COPY.*--from/s/$/_$TARGETARCH/' $BINARIES_DOCKERFILE
          # Output for logging
          cat $BINARIES_DOCKERFILE

          # Artifact testing (avoid build step)
          #echo "." > "$GITHUB_WORKSPACE/komodo/$OUTPUT_FOLDER/periphery_$RUNNER_ARCH"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Komodo binaries
        working-directory: ${{ github.workspace }}/komodo
        run: |
          echo "Building from $BINARIES_DOCKERFILE for $BUILD_PLATFORM"
          # Outputting to local causes the final COPY lines in the Dockerfile to copy
          # files into the specified dest instead of the scratch image.
          docker buildx build -f $BINARIES_DOCKERFILE --platform $BUILD_PLATFORM --output type=local,dest=$OUTPUT_FOLDER .
      
      # Compress each executable in the build folder into its own .tar.gz,
      # renaming to remove the "_<architecture>" suffix beforehand
      # (so periphery_amd64 will be named periphery in the archive)
      - name: Compress artifacts
        working-directory: ${{ github.workspace }}/komodo/${{ env.OUTPUT_FOLDER }}
        run: |
          for filename in ./*; do
              [ -e "$filename" ] || continue
              newname=${filename%_*}
              archive="${filename}.tar.gz"
              mv $filename $newname
              echo $archive
              tar -czvf $archive -C ./ $newname
              mv $newname $filename
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: komodo-alpine-${{ runner.arch }}
          path: ${{ github.workspace }}/komodo/${{ env.OUTPUT_FOLDER }}/*.tar.gz
          retention-days: 1
          overwrite: true


  # Release with build artifacts, only invoked on successful builds
  create-release:
    name: Create release
    runs-on: ubuntu-latest
    needs:
      - release-check
      - komodo-build
    permissions:
      actions: write
      contents: write
    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v5
        with:
          path: ${{ github.workspace }}/artifacts
          merge-multiple: true
    
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          path: komodo-alpine

      - name: Create tag
        shell: bash
        working-directory: ${{ github.workspace }}/komodo-alpine
        run: |
          cd $GITHUB_WORKSPACE/komodo-alpine
          git config --global user.name '${{ github.actor }}'
          git config --global user.email '${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com'
          git tag -l
          git tag -a "${{ needs.release-check.outputs.tag_to_create }}" -m ":lizard: Komodo ${{ needs.release-check.outputs.komodo_tag }}"
          git push origin ${{ needs.release-check.outputs.tag_to_create }}

      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          body: |
            These are prebuilt [Komodo](https://komo.do) binaries for Alpine.
            
            Refer to the [official Komodo release](${{ needs.release-check.outputs.komodo_release_url }}) for changelog and other platforms.
          files: ${{ github.workspace }}/artifacts/*
          tag_name: ${{ needs.release-check.outputs.tag_to_create }}

      # No reason to keep uploaded artifacts around since they've just been attached to the release
      - name: Delete artifacts
        uses: joutvhu/delete-artifact@v2
